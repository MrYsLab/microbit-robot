{
    "docs": [
        {
            "location": "/",
            "text": "micro:bit\nBuilding An Inexpensive Remote Controlled Robot\n\n\n\n.center {\n    margin: auto;\n    width: 50%;\n    padding: 10px;\n}\n\n\n\n\n\n\n\n\n\nINTRODUCTION\n\n\nThe \nmicro:bit\n is an inexpensive, easy to program computer with a slew of\nbuilt-in hardware capabilities:\n\n\n\n\n\n\nA 5x5 LED Matrix\n\n\n\n\n\n\nTwo programmable push buttons.\n\n\n\n\n\n\nAn on-board motion detector.\n\n\n\n\n\n\nA built-in compass.\n\n\n\n\n\n\nA radio module to communicate with other micro:bit computers. \n\n\n\n\n\n\nThese items can be programmed easily using Python, JavaScript or C++.\n\n\nUpon acquiring a micro:bit, I experimented with writing programs for the on-board actuators and sensors\nusing Python. The micro:bit\nPython API is easy to understand and all the devices are simple to monitor and control. Having\nthe \"basics\" under my belt, I started looking for \na more challenging micro:bit project. So I wondered,\nhow easy would it be to create a micro:bit robot vehicle with remote control using the \nmicro:bit radio interface? This would give me the opportunity to experience connecting the micro:bit\nto additional external hardware and see how flexible the micro:bit really is. \n\n\nAnd so, this project was born. Here is my list of what I wanted the vehicle to be capable of doing:\n\n\n\n\n\n\nBe \ninexpesensive\n and \neasily assembled\n from a set of \noff the shelf parts\n. \n\n\n\n\n\n\nBasic mobility capabilities:\n\n\n\n\n\n\nDrive forward\n\n\n\n\n\n\nDrive in reverse\n\n\n\n\n\n\nTurn left\n\n\n\n\n\n\nTurn right\n\n\n\n\n\n\nSpin left\n\n\n\n\n\n\nSpin right\n\n\n\n\n\n\nBrake.\n\n \n    \n\n\n\n\n\n\n\n\n\n\nAdditionally:\n\n\n\n\n\n\nThe robot must have the ability to autonomously perform obstacle avoidance maneuvers\n(we don't want to hit the furniture).\n\n\n\n\n\n\nThe robot must have the ability to be controlled \nremotely using the \nmicro:bit radio interface\n.\n\n\n\n\n\n\nThe following types of remote control interfaces must be provided without the need to\n   re-flash the robot vehicle when changing remote types:\n\n\n\n\n\n\nWeb Page Graphical User Interface(GUI).\n\n\n\n\n\n\nTkinter GUI.\n\n\n\n\n\n\nA micro:bit native \ngestures\n interface.\n\n\n\n\n\n\nAn external \nbutton controller\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the following sections of this document, we will discuss:\n\n\n\n\n\n\nBuilding and coding the robot vehicle.\n\n\n\n\n\n\nCoding and using the remote controllers.\n\n\n\n\n\n\nThe source code for this project is available on \nGitHub\n.",
            "title": "Introduction"
        },
        {
            "location": "/#introduction",
            "text": "The  micro:bit  is an inexpensive, easy to program computer with a slew of\nbuilt-in hardware capabilities:    A 5x5 LED Matrix    Two programmable push buttons.    An on-board motion detector.    A built-in compass.    A radio module to communicate with other micro:bit computers.     These items can be programmed easily using Python, JavaScript or C++.  Upon acquiring a micro:bit, I experimented with writing programs for the on-board actuators and sensors\nusing Python. The micro:bit\nPython API is easy to understand and all the devices are simple to monitor and control. Having\nthe \"basics\" under my belt, I started looking for \na more challenging micro:bit project. So I wondered,\nhow easy would it be to create a micro:bit robot vehicle with remote control using the \nmicro:bit radio interface? This would give me the opportunity to experience connecting the micro:bit\nto additional external hardware and see how flexible the micro:bit really is.   And so, this project was born. Here is my list of what I wanted the vehicle to be capable of doing:    Be  inexpesensive  and  easily assembled  from a set of  off the shelf parts .     Basic mobility capabilities:    Drive forward    Drive in reverse    Turn left    Turn right    Spin left    Spin right    Brake.             Additionally:    The robot must have the ability to autonomously perform obstacle avoidance maneuvers\n(we don't want to hit the furniture).    The robot must have the ability to be controlled \nremotely using the  micro:bit radio interface .    The following types of remote control interfaces must be provided without the need to\n   re-flash the robot vehicle when changing remote types:    Web Page Graphical User Interface(GUI).    Tkinter GUI.    A micro:bit native  gestures  interface.    An external  button controller        In the following sections of this document, we will discuss:    Building and coding the robot vehicle.    Coding and using the remote controllers.    The source code for this project is available on  GitHub .",
            "title": "INTRODUCTION"
        },
        {
            "location": "/robot/",
            "text": "CONSTRUCTION\n\n\nA List Of Components\n\n\nOther than the pair of micro:bit computers, Kitronik motor board and the Sharp Digital Distance sensor,\nfeel free to use any parts or construction practices you wish. Many of these parts came from my\nhardware \"goodie box\" and if you have your own parts on hand, I encourage you to use them to personalize your\nrobot.\n\n\n\n\n\n\n\n\nQuantity\n\n\nComponent\n\n\nCost (USD)\n\n\n\n\n\n\n\n\n\n\n2\n\n\nmicro:bit computers\n\n\n$30.00\n\n\n\n\n\n\n1\n\n\nrobot chassis and motors\n\n\n$14.00\n\n\n\n\n\n\n1\n\n\nKitronik micro:bit motor board\n\n\n$15.00\n\n\n\n\n\n\n1\n\n\nSharp GP2Y0D810Z0F Digital Distance Sensor with Pololu Carrier\n\n\n$7.00\n\n\n\n\n\n\n4\n\n\nAA Batteries\n\n\n$1.00\n\n\n\n\n\n\n1\n\n\nNylon Mounting Hardware\n\n\n$6.50\n\n\n\n\n\n\n1\n\n\nTiny Breadboard\n\n\n$4.00\n\n\n\n\n\n\n1\n\n\nMale to female jumper wires\n\n\n$4.00\n\n\n\n\n\n\n1\n\n\nBreakaway male header pins\n\n\n$5.00\n\n\n\n\n\n\n\n\nAssembly\n\n\n\n.center {\n    margin: auto;\n    width: 50%;\n    padding: 10px;\n}</p>\n<p>\n\n\n\n\n\n1. Assemble the robot by \nfollowing these instructions.\n\n\n\n\n\n\n\n2. Measure a breakaway header and solder it to the breakout pins of the Kitronic motor board.\nPlace the short pins into the breakout pads from the top of the board, exposing the longer pins.\n\n\n\n\n\n\n\n3. Using the pins that come with the Sharp Digital Distance Sensor, solder the straight pins\nto the module.\n\n\n\n\n\n\n\n4. Mount the Kitronik motor board to the robot chasis using the nylon mounting hardware.\n\n\n\n\n\n\n\n5. Wire the motors and battery to the motor board. Kitronic instructions may be found \nhere\n.\n\n\n\n\n\n\n\n6. Peel off the adhesive cover from the Tiny Bread Board and mount on the robot chasis.\n\n\n\n\n7. Place the digital distance sensor in the breadboard.\n\n\n\n\n\n\n\n8. Using the male to female jumpers connect the OUT pin on the sensor module to pin 15 on the Kitronik header,\nVIN to 3V and GND to GND.\n\n\n\n\n\n\n\n\n\n9. Plug a micro:bit into the slot on the Kitroniks motor board.\n\n\n\n10. Your robot is now ready for a software load!\n\n\n\n\n\n\n\n\nCODING THE ROBOT\n\n\nA Note On Minifying Code\n\n\nAll micro:bit MicroPython files for this project are supplied in 2 formats, a fully commented format and a \"minified\" format.\nThe minified format removes all comments and unnecessary white space. The micro:bit has limited resources, so we\nwant to maximize every bit of space we can for useful executable code. To do this, we \"minify\" the fully commented file using\n\npyminifier\n.\n\n\nThe pyminifier utility can be installed on your computer using \npip\n.\n\n\nFor Windows:\n\n\npip install pyminifer\n\n\n\n\nFor Linux/Mac:\n\n\nsudo pip3 install pyminifer\n\n\n\n\nOnce installed, it's easy to use. Pyminifier accepts an input file and creates a minified version,\n leaving the original file intact. \n\n\nHere is a sample of a fully commented file, called min_ex.py.\n\n\n# This is a demo file to illustrate using the pyminifier utility.\n# Usage of pyminifier with this file:\n#    pyminifier -o min_ex_min.py mix_ex.py\n\ndef some_function(a, b, c):\n    \"\"\"\n    This is a sample function with three input parameters\n    :param a: input 1\n    :param b: input 2\n    :param c: input 3\n    :return: the result of adding a+b+c\n    \"\"\"\n    sum = a + b + c\n    return sum\n\n\n\n\nTo minify this file, open a command/terminal window, \nthen type the following command:\n\n\npyminifier -o min_ex_min.py min_ex.py\n\n\n\n\nThe \n-o\n option specifies the name of the minified file, and the last parameter is the name of the \nsource file to minify.\n\n\nThis will create a new file called \nmin_ex_min.py\n while leaving \nmin_ex.py\n intact.\n\n\nHere is the result:\n\n\ndef some_function(a,b,c):\n sum=a+b+c\n return sum\n\n\n\n\nSo after running this command, we still have our original file to refer to and maintain, and a minified, stripped down\nversion, to flash to the micro:bit\n\n\nUsing 3rd Party Libraries With micro:bit MicroPython\n\n\nIn Python, to utilize a 3rd party module or library, we normally install it using a tool like \npip\n, and then add\nan \nimport\n statement to our source file to include the library in our project.\n\n\nFor the micro:bit, things work a bit differently. You can still use an import statement if you wish, but the \nthe \nprocedure\n\nto do so is somewhat cumbersome. A simpler and more straight forward approach is to simply copy the library source code \nto the top of your application source file and then add your code below it.\n\n\nFor the robot, we are going to take advantage of the \nkitronic_motor_board library\n\nto provide motor control.\n\n\nIf you look at \nmicrobit_robot.py\n, you will see the KMotor class at the top of the file. This class is the source for the \nkitronic_motor_board library that was copied and pasted into our file.\n\n\nThe kitronic_motor_board Library\n\n\nYou can read the full API documentation for the \nkitronic_motor_board library\n on\nthe GitHub web page, but in a nutshell, it provides a simple API for motor control that allows one to select a motor \nand turn it on in either the forward or reverse direction, or place it in a hard brake or coast state.\n\n\nThe microbit_robot Source Code\n\n\nThe \nRobot\n class provides both robot control\nand an interface to the outside world using the micro:bit radio.\n\n\nLet's take a look at this class in a little more detail.\n\n\nThe \n__init__\n method first creates an instance of the KMotor library class. It then\ndisplays a \"HAPPY\" image on the micro:bit display to let us know that the robot is \"alive\".\n\n\nclass Robot:\n    \"\"\"\n    This class runs a simple 2 wheel/2motor robot.\n    It listens for commands over the radio interface\n    and dispatches the method associated with the command.\n\n    It also monitors the Sharp GP2Y0D810Z0F Digital Distance Sensor\n    for objects that are in front of the robot\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Instantiate an instance of KMotor.\n        Display a \"smile\" to let the use know that upon\n        first power up, we are alive.\n        Create a dispatch table for each radio command.\n        Turn on the radio and wait for commands to come in.\n        \"\"\"\n\n        # instantiate a motor object\n        self.km = KMotor()\n\n        # display something so that we know the board is\n        # alive\n        display.show(Image.HAPPY)\n\n\n\n\n\nNext, a \"dispatch dictionary\" is constructed to help find and execute each command\nthat is received over the micro:bit radio interface. The radio interface is then enabled:\n\n\n        # build a dispatch dictionary to allow us\n        # to quickly execute each incoming command\n        self.dispatch = {'fwd': self.go_forward,\n                         'rev': self.go_reverse,\n                         'left': self.go_left,\n                         'right': self.go_right,\n                         'spin_right': self.spin_right,\n                         'spin_left': self.spin_left,\n                         'stop': self.stop,\n                         }\n        # turn on the micro:bit radio so that we can receive commands.\n        radio.on()\n\n\n\n\n\nWe then go into the event loop. First the loop checks the distance sensor to see if the\nrobot needs to take evasive action. The sensor returns a digital 0 when something is near,\nand has the robot reverse direction for 1 second, turn right for 1 second and then turns\nthe motors off when the robot is in range of an obstacle.\n\n\nThe loop continues and checks to see if a command has been received over the radio interface.\nIf a command is available, its associated method is retrieved from the the dispatch table and is executed:\n\n\n        while True:\n            # check to see if we need to perform an avoidance maneuver.\n            # when an object is near, the distance sensor returns a digital 0.\n            # if a crash is imminent, reverse and go right\n            if not pin15.read_digital():\n                self.go_reverse()\n                sleep(1000)\n                self.go_right()\n                sleep(1000)\n                self.stop()\n\n            # get next command\n            cmd = radio.receive()\n            if cmd is None:\n                pass\n            else:\n                # move motors based on command\n                # fetch command from command table\n                op = self.dispatch.get(cmd, None)\n                # if a command has been fetched, execute it\n                if op:\n                    op()\n\n\n\n\nThe motion command methods follow next:\n\n\n    # motion command handlers\n    def go_forward(self):\n        display.show(Image.ARROW_N)\n        # adjust speeds to help robot go straight\n        self.km.motor_on(self.km.MOTOR_1, self.km.FORWARD, 60)\n        self.km.motor_on(self.km.MOTOR_2, self.km.FORWARD, 60)\n\n    def go_reverse(self):\n        display.show(Image.ARROW_S)\n        # adjust speeds to help robot go straight\n        self.km.motor_on(self.km.MOTOR_1, self.km.REVERSE, 70)\n        self.km.motor_on(self.km.MOTOR_2, self.km.REVERSE)\n\n    def go_left(self):\n        display.show(Image.ARROW_W)\n        # adjust speed to turn the robot\n        self.km.motor_on(self.km.MOTOR_1, self.km.FORWARD, 40)\n        self.km.motor_on(self.km.MOTOR_2, self.km.FORWARD)\n\n    def go_right(self):\n        display.show(Image.ARROW_E)\n        # adjust speed to turn the robot\n        self.km.motor_on(self.km.MOTOR_1, self.km.FORWARD)\n        self.km.motor_on(self.km.MOTOR_2, self.km.FORWARD, 40)\n\n    def spin_right(self):\n        display.show(Image.ARROW_NE)\n        self.km.motor_on(self.km.MOTOR_1, self.km.FORWARD)\n        self.km.motor_on(self.km.MOTOR_2, self.km.REVERSE)\n\n    def spin_left(self):\n        display.show(Image.ARROW_SW)\n        self.km.motor_on(self.km.MOTOR_2, self.km.FORWARD)\n        self.km.motor_on(self.km.MOTOR_1, self.km.REVERSE)\n\n    def stop(self):\n        self.km.motor_off(self.km.MOTOR_1)\n        self.km.motor_off(self.km.MOTOR_2)\n        display.clear()\n\n\n# instantiate a Robot\nr = Robot()\n\n\n\n\nEach command method displays an image on the display, or for the stop command, clears the display in order to preserve\nbattery life. Each method invokes the appropriate KMotor method to control the motors.\n\n\nFLASHING MICROBIT_ROBOT_MIN.PY\n\n\nUsing your favorite editor, such as PyCharm (using \npseudo-microbit\n or the micropython plugin), \nthe \nMu Editor\n, or the \non-line editor\n, cut and paste \n\nmicrobit_robot_min.py\n into your editor and flash it onto the micro:bit. \n\n\nThe robot is now ready to be controlled by one of the remote controllers.",
            "title": "The Robot"
        },
        {
            "location": "/robot/#construction",
            "text": "",
            "title": "CONSTRUCTION"
        },
        {
            "location": "/robot/#a-list-of-components",
            "text": "Other than the pair of micro:bit computers, Kitronik motor board and the Sharp Digital Distance sensor,\nfeel free to use any parts or construction practices you wish. Many of these parts came from my\nhardware \"goodie box\" and if you have your own parts on hand, I encourage you to use them to personalize your\nrobot.     Quantity  Component  Cost (USD)      2  micro:bit computers  $30.00    1  robot chassis and motors  $14.00    1  Kitronik micro:bit motor board  $15.00    1  Sharp GP2Y0D810Z0F Digital Distance Sensor with Pololu Carrier  $7.00    4  AA Batteries  $1.00    1  Nylon Mounting Hardware  $6.50    1  Tiny Breadboard  $4.00    1  Male to female jumper wires  $4.00    1  Breakaway male header pins  $5.00",
            "title": "A List Of Components"
        },
        {
            "location": "/robot/#assembly",
            "text": ".center {\n    margin: auto;\n    width: 50%;\n    padding: 10px;\n}</p>\n<p>   \n1. Assemble the robot by  following these instructions.    \n2. Measure a breakaway header and solder it to the breakout pins of the Kitronic motor board.\nPlace the short pins into the breakout pads from the top of the board, exposing the longer pins.    \n3. Using the pins that come with the Sharp Digital Distance Sensor, solder the straight pins\nto the module.    \n4. Mount the Kitronik motor board to the robot chasis using the nylon mounting hardware.    \n5. Wire the motors and battery to the motor board. Kitronic instructions may be found  here .    \n6. Peel off the adhesive cover from the Tiny Bread Board and mount on the robot chasis.  \n7. Place the digital distance sensor in the breadboard.    \n8. Using the male to female jumpers connect the OUT pin on the sensor module to pin 15 on the Kitronik header,\nVIN to 3V and GND to GND.     \n9. Plug a micro:bit into the slot on the Kitroniks motor board.  \n10. Your robot is now ready for a software load!",
            "title": "Assembly"
        },
        {
            "location": "/robot/#coding-the-robot",
            "text": "",
            "title": "CODING THE ROBOT"
        },
        {
            "location": "/robot/#a-note-on-minifying-code",
            "text": "All micro:bit MicroPython files for this project are supplied in 2 formats, a fully commented format and a \"minified\" format.\nThe minified format removes all comments and unnecessary white space. The micro:bit has limited resources, so we\nwant to maximize every bit of space we can for useful executable code. To do this, we \"minify\" the fully commented file using pyminifier .  The pyminifier utility can be installed on your computer using  pip .  For Windows:  pip install pyminifer  For Linux/Mac:  sudo pip3 install pyminifer  Once installed, it's easy to use. Pyminifier accepts an input file and creates a minified version,\n leaving the original file intact.   Here is a sample of a fully commented file, called min_ex.py.  # This is a demo file to illustrate using the pyminifier utility.\n# Usage of pyminifier with this file:\n#    pyminifier -o min_ex_min.py mix_ex.py\n\ndef some_function(a, b, c):\n    \"\"\"\n    This is a sample function with three input parameters\n    :param a: input 1\n    :param b: input 2\n    :param c: input 3\n    :return: the result of adding a+b+c\n    \"\"\"\n    sum = a + b + c\n    return sum  To minify this file, open a command/terminal window, \nthen type the following command:  pyminifier -o min_ex_min.py min_ex.py  The  -o  option specifies the name of the minified file, and the last parameter is the name of the \nsource file to minify.  This will create a new file called  min_ex_min.py  while leaving  min_ex.py  intact.  Here is the result:  def some_function(a,b,c):\n sum=a+b+c\n return sum  So after running this command, we still have our original file to refer to and maintain, and a minified, stripped down\nversion, to flash to the micro:bit",
            "title": "A Note On Minifying Code"
        },
        {
            "location": "/robot/#using-3rd-party-libraries-with-microbit-micropython",
            "text": "In Python, to utilize a 3rd party module or library, we normally install it using a tool like  pip , and then add\nan  import  statement to our source file to include the library in our project.  For the micro:bit, things work a bit differently. You can still use an import statement if you wish, but the \nthe  procedure \nto do so is somewhat cumbersome. A simpler and more straight forward approach is to simply copy the library source code \nto the top of your application source file and then add your code below it.  For the robot, we are going to take advantage of the  kitronic_motor_board library \nto provide motor control.  If you look at  microbit_robot.py , you will see the KMotor class at the top of the file. This class is the source for the \nkitronic_motor_board library that was copied and pasted into our file.",
            "title": "Using 3rd Party Libraries With micro:bit MicroPython"
        },
        {
            "location": "/robot/#the-kitronic_motor_board-library",
            "text": "You can read the full API documentation for the  kitronic_motor_board library  on\nthe GitHub web page, but in a nutshell, it provides a simple API for motor control that allows one to select a motor \nand turn it on in either the forward or reverse direction, or place it in a hard brake or coast state.",
            "title": "The kitronic_motor_board Library"
        },
        {
            "location": "/robot/#the-microbit_robot-source-code",
            "text": "The  Robot  class provides both robot control\nand an interface to the outside world using the micro:bit radio.  Let's take a look at this class in a little more detail.  The  __init__  method first creates an instance of the KMotor library class. It then\ndisplays a \"HAPPY\" image on the micro:bit display to let us know that the robot is \"alive\".  class Robot:\n    \"\"\"\n    This class runs a simple 2 wheel/2motor robot.\n    It listens for commands over the radio interface\n    and dispatches the method associated with the command.\n\n    It also monitors the Sharp GP2Y0D810Z0F Digital Distance Sensor\n    for objects that are in front of the robot\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Instantiate an instance of KMotor.\n        Display a \"smile\" to let the use know that upon\n        first power up, we are alive.\n        Create a dispatch table for each radio command.\n        Turn on the radio and wait for commands to come in.\n        \"\"\"\n\n        # instantiate a motor object\n        self.km = KMotor()\n\n        # display something so that we know the board is\n        # alive\n        display.show(Image.HAPPY)  Next, a \"dispatch dictionary\" is constructed to help find and execute each command\nthat is received over the micro:bit radio interface. The radio interface is then enabled:          # build a dispatch dictionary to allow us\n        # to quickly execute each incoming command\n        self.dispatch = {'fwd': self.go_forward,\n                         'rev': self.go_reverse,\n                         'left': self.go_left,\n                         'right': self.go_right,\n                         'spin_right': self.spin_right,\n                         'spin_left': self.spin_left,\n                         'stop': self.stop,\n                         }\n        # turn on the micro:bit radio so that we can receive commands.\n        radio.on()  We then go into the event loop. First the loop checks the distance sensor to see if the\nrobot needs to take evasive action. The sensor returns a digital 0 when something is near,\nand has the robot reverse direction for 1 second, turn right for 1 second and then turns\nthe motors off when the robot is in range of an obstacle.  The loop continues and checks to see if a command has been received over the radio interface.\nIf a command is available, its associated method is retrieved from the the dispatch table and is executed:          while True:\n            # check to see if we need to perform an avoidance maneuver.\n            # when an object is near, the distance sensor returns a digital 0.\n            # if a crash is imminent, reverse and go right\n            if not pin15.read_digital():\n                self.go_reverse()\n                sleep(1000)\n                self.go_right()\n                sleep(1000)\n                self.stop()\n\n            # get next command\n            cmd = radio.receive()\n            if cmd is None:\n                pass\n            else:\n                # move motors based on command\n                # fetch command from command table\n                op = self.dispatch.get(cmd, None)\n                # if a command has been fetched, execute it\n                if op:\n                    op()  The motion command methods follow next:      # motion command handlers\n    def go_forward(self):\n        display.show(Image.ARROW_N)\n        # adjust speeds to help robot go straight\n        self.km.motor_on(self.km.MOTOR_1, self.km.FORWARD, 60)\n        self.km.motor_on(self.km.MOTOR_2, self.km.FORWARD, 60)\n\n    def go_reverse(self):\n        display.show(Image.ARROW_S)\n        # adjust speeds to help robot go straight\n        self.km.motor_on(self.km.MOTOR_1, self.km.REVERSE, 70)\n        self.km.motor_on(self.km.MOTOR_2, self.km.REVERSE)\n\n    def go_left(self):\n        display.show(Image.ARROW_W)\n        # adjust speed to turn the robot\n        self.km.motor_on(self.km.MOTOR_1, self.km.FORWARD, 40)\n        self.km.motor_on(self.km.MOTOR_2, self.km.FORWARD)\n\n    def go_right(self):\n        display.show(Image.ARROW_E)\n        # adjust speed to turn the robot\n        self.km.motor_on(self.km.MOTOR_1, self.km.FORWARD)\n        self.km.motor_on(self.km.MOTOR_2, self.km.FORWARD, 40)\n\n    def spin_right(self):\n        display.show(Image.ARROW_NE)\n        self.km.motor_on(self.km.MOTOR_1, self.km.FORWARD)\n        self.km.motor_on(self.km.MOTOR_2, self.km.REVERSE)\n\n    def spin_left(self):\n        display.show(Image.ARROW_SW)\n        self.km.motor_on(self.km.MOTOR_2, self.km.FORWARD)\n        self.km.motor_on(self.km.MOTOR_1, self.km.REVERSE)\n\n    def stop(self):\n        self.km.motor_off(self.km.MOTOR_1)\n        self.km.motor_off(self.km.MOTOR_2)\n        display.clear()\n\n\n# instantiate a Robot\nr = Robot()  Each command method displays an image on the display, or for the stop command, clears the display in order to preserve\nbattery life. Each method invokes the appropriate KMotor method to control the motors.",
            "title": "The microbit_robot Source Code"
        },
        {
            "location": "/robot/#flashing-microbit_robot_minpy",
            "text": "Using your favorite editor, such as PyCharm (using  pseudo-microbit  or the micropython plugin), \nthe  Mu Editor , or the  on-line editor , cut and paste  microbit_robot_min.py  into your editor and flash it onto the micro:bit.   The robot is now ready to be controlled by one of the remote controllers.",
            "title": "FLASHING MICROBIT_ROBOT_MIN.PY"
        },
        {
            "location": "/controllers/",
            "text": "A Choice Of 4 Remote Controllers\n\n\nTo demonstrate the flexibility of the micro:bit, 4 different remote controllers\nhave been developed:\n\n\n\n\n\n\nA micro:bit \ngesture\n controller - translates micro:bit gestures into robot commands.\n\n\n\n\n\n\nA Web Page GUI - provides 6 buttons in your browser to control the robot.\n\n\n\n\n\n\nA tkinter GUI - provides 6 buttons on screen to control the robot.\n\n\n\n\n\n\nA \nSparkFun gamer:bit\n push button interface.\n\n\n\n\n\n\nThe control protocol between the robot is consistent across all controllers, so the\n   robot only need be flashed once to use any of the controllers.\n\n\n1. GESTURE CONTROLLER\n\n\n\n\n\n\n\n\nThis controller consists of a standalone micro:bit. Robot motion is directed by \nchanging the micro:bit's orientation: \n\n\n\n\n\n\nPoint the USB connector towards the floor to direct the robot to go forward.\n\n\n\n\n\n\nPoint the USB connector towards the ceiling to direct the robot to go in reverse.\n\n\n\n\n\n\nPoint Button A (without pressing it )towards the floor to direct the robot to go left.\n\n\n\n\n\n\nPoint Button A (without pressing it )towards the ceiling to direct the robot to go right.\n\n\n\n\n\n\nPress Button A to spin left.\n\n\n\n\n\n\nPress Button B to spin right.\n\n\n\n\n\n\nHold the micro:bit parallel to the floor and ceiling, and the robot stops.\n\n\n\n\n\n\nTo use the gesture controller, flash \ngesture_controller_min.py\n\n onto the controller micro:bit, and you are ready to go.\n\n\nGesture Controller Code\n\n\nfrom microbit import *\nimport radio\n\n# the last gesture detected\nlast_gesture = ''\n\ndef send_command(cmd):\n    \"\"\"\n    This function sends a command to the radio.\n    :param cmd: Command string\n    :return:\n    \"\"\"\n    radio.on()\n    radio.send(cmd)\n    sleep(100)\n    radio.off()\n\n# the main loop\nwhile True:\n    # get the current gesture\n    gesture = accelerometer.current_gesture()\n\n    # if either button is pressed, translate this to\n    # a pseudo gesture\n    if button_a.is_pressed():\n        gesture = 'spin_left'\n    if button_b.is_pressed():\n        gesture = 'spin_right'\n\n    # if this gesture is different than the last,\n    # build the command string and transmit it over the radio.\n    if not last_gesture == gesture:\n        last_gesture = gesture\n        if gesture == 'down':\n            display.show(Image.ARROW_N)\n            send_command('fwd')\n        elif gesture == 'up':\n            display.show(Image.ARROW_S)\n            send_command('rev')\n        elif gesture == 'left':\n            display.show(Image.ARROW_W)\n            send_command('left')\n        elif gesture == 'right':\n            display.show(Image.ARROW_E)\n            send_command('right')\n        elif gesture == 'spin_left':\n            display.show(Image.ARROW_NW)\n            send_command('spin_left')\n        elif gesture == 'spin_right':\n            display.show(Image.ARROW_NE)\n            send_command('spin_right')\n        else:\n            display.show(Image.NO)\n            send_command('stop')\n\n\n\n\n\nA motion control message is sent to the robot only if a new motion command is detected.\nThis helps preserve battery life for both the controller and the robot.\n\n\nLooking at the event loop, it begins by retrieving the current micro:bit gesture.\n\n\nIt then checks the state of Button A and Button B to see if the user wishes to spin\nthe robot in either direction. If either of the buttons is currently pressed,\nthe button press is translated into a \"pseudo gesture\" and saved.\nThis allows the button presses to emulate the behavior of a true gesture change.\n\n\nNext the current gesture is compared to the one saved from the previous cycle. If it is\nthe same, no action is taken, but if it is different, then the appropriate motion\nmessage is sent to the robot by passing the message to the send_command function. This function turns the\nradio on, transmits the command and then turns the radio off. \nIn addition an arrow image is displayed to show the motion\ncommand detected, or an \"X\" is displayed if the robot is stopped.\n\n\nGUI BASED CONTROLLERS\n\n\nThe GUI based controllers each consist of 2 components. The first component is a Python script\nthat runs on a PC and connects to the controller micro:bit via the serial/USB cable. There are separate Python scripts \nfor each of the GUI controllers, that is\nthe Web based GUI and tkinter based GUI. These scripts\ndetect GUI button press events, and when an event change is detected, it sends a serial\nmessage to the micro:bit. The micro:bit translates these serial messages into radio commands\nand transmits those to the robot.\n\n\n\n\n\n\n\n\nThe gui_radio_bridge\n\n\nAs described above, the gui_radio_bridge translates serial messages generated\n by the GUI scripts into radio messages.\n\n\nIt needs to be flashed onto the controller micro:bit before either of the PC GUI scripts can run.\n\n\nTo flash the gui_radio_bridge, just copy the code from \ngui_radio_bridge_min.py\n\nto your favorite micro:bit editor and flash it. \n\n\nThe gui_radio_bridge Code.\n\n\nfrom microbit import *\nimport radio\n\nwhile True:\n    # get data from serial link\n    data = uart.readline()\n    sleep(8)\n    if data:\n        # send data out over the radio\n        cmd = str(data, 'utf-8').rstrip()\n        radio.on()\n        radio.send(cmd)\n        radio.off()\n\n\n\n\n\n\nThe code for this script is very simple. The loop waits for an incoming line of text to be received\nover the serial link from the PC.\nWhen a line is received, it turns the radio on,\nsends the received string out via the radio interface, and then turns the radio off.\n\n\n2. THE WEB PAGE GUI CONTROLLER\n\n\n\n.center {\n    margin: auto;\n    width: 85%;\n    padding: 10px;\n}</p>\n<p>\n\n\n\n\n\n\nThe remi GUI Builder\n\n\nThe GUI Web page shown above, was created using a drag and drop editing tool included with the\n\nremi\n GUI builder. Click on the \nremi\n link to the left if you are interested\nin learning how to use remi to create interactive web pages in pure Python.\nThe editor not only allows you to layout the web page, but it generates the code for the page as well,\nincluding stubs for any desired GUI events, such as button clicks. If you prefer to code directly in Python\nwithout the aid of the editor, the remi API is succinct and easy to understand.\n\n\nThe GUI and its associated web server are run on a PC, and it connects to a micro:bit via a serial USB link.\nThe code running on the controller micro:bit is the \ngui_radio_bridge\n.\nThe bridge translates the serial commands coming from the GUI to micro:bit radio messages.\n\n\nBefore running this GUI, you will need to install remi on your PC, so please follow the \ninstallation instructions on the \nremi GitHub home page\n.\n\n\nI cannot emphasize enough how easily remi makes generating Web based GUIs. You don't have to know any HTML, CSS\nor JavaScript\nand can modify the page in pure Python. In addition, its author provides great support if you have questions\non using the tool.\n\n\nWeb GUI Code\n\n\nAs mentioned earlier, the bulk of the code for this GUI was automatically generated by the remi editor.\nWhat will be shown and described here are the added or modified sections of code. Code that was not\nmodified, will not be shown or discussed. If you would like to\nsee the file in its entirety, please look at \nweb_remote_controller.py\n.\n\n\nThe entire Web GUI is encapsulated in a single Python class, called \nRobotController\n.\n\n\nModifications Or Additions To The Generated Code\n\n\n__init__\n\n\nIn the \n__init__\n method, two lines were added to the generated code. The added code creates\nvariables to hold the serial com port, used to communicate with\nthe \ngui_radio_bridge\n, and another variable to hold the instance of the serial object used to send data to the bridge.\n\n\nclass RobotController(App):\n    def __init__(self, *args, **kwargs):\n        self.com_port = None\n        self.micro_bit_serial = None\n        if not 'editing_mode' in kwargs.keys():\n            super(RobotController, self).__init__(*args, static_file_path='./res/')\n\n\n\n\nmain\n\n\nThe main method, generated by the editor consists of a single line, that calls the ui_constructor\nmethod that instantiates all the widgets on the page. This is the last line in the code below.\n\n\nThe code that has been added to \nmain\n performs micro:bit serial port auto-detection.\n\n\n    def main(self):\n        print('Autodetecting serial port. Please wait...')\n        if sys.platform.startswith('darwin'):\n            locations = glob.glob('/dev/tty.[usb*]*')\n            locations = glob.glob('/dev/tty.[wchusb*]*') + locations\n            locations.append('end')\n            # for everyone else, here is a list of possible ports\n        else:\n            locations = ['dev/ttyACM0', '/dev/ttyACM0', '/dev/ttyACM1',\n                         '/dev/ttyACM2', '/dev/ttyACM3', '/dev/ttyACM4',\n                         '/dev/ttyACM5', '/dev/ttyUSB0', '/dev/ttyUSB1',\n                         '/dev/ttyUSB2', '/dev/ttyUSB3', '/dev/ttyUSB4',\n                         '/dev/ttyUSB5', '/dev/ttyUSB6', '/dev/ttyUSB7',\n                         '/dev/ttyUSB8', '/dev/ttyUSB9',\n                         '/dev/ttyUSB10',\n                         '/dev/ttyS0', '/dev/ttyS1', '/dev/ttyS2',\n                         '/dev/tty.usbserial', '/dev/tty.usbmodem', 'com2',\n                         'com3', 'com4', 'com5', 'com6', 'com7', 'com8',\n                         'com9', 'com10', 'com11', 'com12', 'com13',\n                         'com14', 'com15', 'com16', 'com17', 'com18',\n                         'com19', 'com20', 'com21', 'com22', 'com23', 'com24',\n                         'com25', 'com26', 'com27', 'com28', 'com29', 'com30',\n                         'com31', 'com32', 'com33', 'com34', 'com35', 'com36',\n                         'com1', 'end'\n                         ]\n\n        detected = None\n        for device in locations:\n            try:\n                self.micro_bit_serial = serial.Serial(port=device, baudrate=115200,\n                                                      timeout=.1)\n                detected = device\n                break\n            except serial.SerialException:\n                if device == 'end':\n                    print('Unable to find Serial Port, Please plug in '\n                          'cable or check cable connections.')\n                    detected = None\n                    exit()\n            except OSError:\n                pass\n        self.com_port = detected\n\n        # open and close the port to flush the serial buffers\n        self.micro_bit_serial.close()\n        self.micro_bit_serial.open()\n        time.sleep(.05)\n        print('Port found: ', self.com_port)\n        return RobotController.construct_ui(self)\n\n\n\n\n\nconstruct_ui\n\n\nThis method is generated by the GUI editor and was not modified. It both instantiates all of the GUI widgets\nand peforms their layout on the web page.\n\n\nThe Event Handlers\n\n\nThe remi editor allows you to select events of interest for each widget, and then creates\na stub method to handle each event. You just need to add the code specific to your application for\nthat event.\n\n\nLet's look at the handlers for the \nForward\n button. Handlers for all of the other buttons are very similar.\n\n\n    def onmousedown_btn_forward(self, emitter, x, y):\n        print('fdown')\n        self.write_to_mb('fwd')\n\n    def onmouseup_btn_forward(self, emitter, x, y):\n        print('fup')\n        self.write_to_mb('stop')\n\n\n\n\nThere are 2 events associated with this button, that is, when the button is pressed and when it is released.\nThe print statements were added to send debugging information to the console, and can optionally be\ndeleted.\n\n\nwrite_to_mb\n\n\nThe \nwrite_to_mb\n method sends the command over the serial port to the micro:bit. It is an additional method added to the \nRobotController class.\n\n\n    def write_to_mb(self, msg):\n        msg = bytes(msg.encode())\n        self.micro_bit_serial.write(msg)\n\n\n\n\nGUI Instantiation\n\n\nThe last section of the code instantiates the GUI.\n\n\nconfiguration = {'config_project_name': 'RobotController', \n                 'config_address': '0.0.0.0', 'config_port': 8081, \n                 'config_multiple_instance': True, \n                 'config_enable_file_cache': True, \n                 'config_start_browser': True, 'config_resourcepath': './res/'}\n\nif __name__ == \"__main__\":\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    # use the google dns\n    s.connect(('8.8.8.8', 0))\n    # start(MyApp,address='127.0.0.1', port=8081, \n    #       multiple_instance=False,enable_file_cache=True, \n    #       update_interval=0.1, start_browser=True)\n    start(RobotController, address=s.getsockname()[0], port=configuration['config_port'],\n                        multiple_instance=configuration['config_multiple_instance'],\n                        enable_file_cache=configuration['config_enable_file_cache'],\n                        start_browser=configuration['config_start_browser'])\n\n\n\n\n\nMost of this code was generated by the editor. The \nconfiguration\n dictionary was not modified. It contains\ndefault entries that can be used when instantiating the GUI.\n\n\nThe default IP address for the web server is 127.0.0.0.1 as shown in the commented out \nstart\n line. I wanted to be\nable to expose the web server to browsers on other computers, so the s.connect and s.getsockname calls allow\nfor discovery of the IP address of the machine running the webserver. The rest of the parameters are \nthe system defaults, and you can find out more about those on the \nremi\n GitHub page.\n\n\nRunning The Web Based GUI\n\n\n\n\nFlash the \ngui_radio_bridge\n on to the micro:bit acting as the remote.\n\n\nConnect the micro:bit to the computer that will run the GUI with a USB cable.\n\n\nRun \nweb_remote_controller.py\n from a command or terminal window. \n\n\nOpen up your web browser and use the announced httpserver URL to \n   access the GUI. For example \nhttp://192.168.2.188:8081\n \n\n\n\n\n   $ python3 web_remote_controller.py\n        remi.server      INFO     Started websocket server 192.168.2.188:43723\n        remi.server      INFO     Started httpserver http://192.168.2.188:8081/\n        remi.request     INFO     built UI (path=/)\n        Autodetecting serial port. Please wait...\n        Port found:  /dev/ttyACM0\n        remi.server.ws   INFO     connection established: ('192.168.2.188', 54508)\n        remi.server.ws   INFO     handshake complete\n\n\n\n\nPressing a GUI button initiates motor movement, and releasing it stops the motors.\n\n\n3. THE TKINTER GUI CONTROLLER\n\n\n\n\n\n\n\n\nThe tkinter GUI runs on a PC, and it connects to a micro:bit via a serial USB link.\nThe code running on the micro:bit is the \ngui_radio_bridge\n.\nThe bridge translates the serial commands coming from the GUI to micro:bit radio messages.\n\n\ntk_controller Code\n\n\nThe code is structured similarly to the remi gui. Since tkinter programming is beyond the\nscope of this guide, this discussion will be limited to one of general functionality. If you wish to\nlearn more about creating tkinter applications, I can recommend\n\n\"Modern Tkinter for Busy Python Developers\", by Mark Roseman\n\n as a reference.\n\n\nYou may refer to the actual source code by looking at \ntk_controller.py\n.\n\n\nThe \n__init__\n method:\n\n\n\n\nAuto-detects the micro:bit serial port\n\n\nInitializes the tkinter framework\n\n\n\n\nCalls the \ncreate_control_frame\n method.\n\n\n\n\nCreate_control_frame instantiates and performs layout for all the GUI widgets\n\n\nAssociates event handlers for each widget. \n\n\n\n\n\n\n\n\nEvent handlers are provided for each GUI event identified in \ncreate_control_frame\n. \n\n\nRunning The tkinter Based GUI\n\n\n\n\nFlash the \ngui_radio_bridge\n on to the micro:bit acting as the remote.\n\n\nConnect the micro:bit to the computer that will run the GUI using a USB cable.\n\n\nRun \ntk_controller.py\n from a command or terminal window.\n\n\n\n\n      python3 tk_controller.py\n\n\n\n\nPressing a button initiates robot motion and when a button is released robot motion is stopped.\n\n\n4. THE GAMER:BIT CONTROLLER\n\n\n\n\n\n\n\n\nThis controller requires the purchase of a \nSparkFun gamer:bit\n\n\nThe buttons on the left hand side of the gamer:bit are used to control forward, reverse, left and right motion.\nThe buttons on the right control both left and right spinning motion.\n\n\nPressing a button initiates robot motion and when a button is released robot motion is stopped.\n\n\nGamerbit Code\n\n\nThe code for this controller utilizes the \ngamerbit\n\n\nthird party library\n.\n\n\nIf you look at \ngb_remote_control.py\n, the gamerbit library, that is, the GamerBit class, \nis placed at the top of the file.\n\n\nclass GamerBit:\n    def __init__(self, callback, scans=1):\n        self.pins = [pin0, pin1, pin2, pin8, pin12, pin16, button_a, button_b]\n        self.callback = callback\n        self.number_of_scans = scans\n        for pin in self.pins[:-2]:\n            pin.set_pull(pin.PULL_UP)\n        self.previous_readings = [0] * 8\n        self.current_readings = [0] * 8\n        self._scanner()\n\n    def scan(self):\n        readings = [int(not pin.read_digital()) for pin in self.pins[:-2]]\n        readings.append(int(button_a.is_pressed()))\n        readings.append(int(button_b.is_pressed()))\n        self.current_readings = [int(self.current_readings[pin] or readings[pin]) for pin in range(0, len(readings))]\n\n    def _scanner(self):\n        pin_ids = ['pin0', 'pin1', 'pin2', 'pin8', 'pin12', 'pin16', 'button_a', 'button_b']\n        while True:\n            for scans in range(0, self.number_of_scans):\n                self.scan()\n            report = {}\n            for x in range(0, 8):\n                if self.current_readings[x] != self.previous_readings[x]:\n                    report[pin_ids[x]] = self.current_readings[x]\n            self.previous_readings = self.current_readings\n            self.current_readings = [0] * 8\n            if report:\n                if self.callback:\n                    self.callback(report)\n\n\ndef gb_callback(report):\n    \"\"\"\n    This function is called by the GamerBit class when a button\n    state change is detected. It translates the button presses\n    and releases into messages that are sent over the radio\n    interface and received by microbit_robot.py\n    :param report: A GamerBit report dictionary\n    :return:\n    \"\"\"\n    # turn on the radio\n    radio.on()\n    for key in report:\n        value = report[key]\n        # if the button was released, send a stop command\n        if value == 0:\n            radio.send('stop')\n            radio.send('stop')\n            sleep(10)\n            radio.send('stop')\n\n        # send a command associated with each button\n        else:\n            if key == 'pin0':\n                radio.send('fwd')\n                print('fwd')\n            elif key == 'pin8':\n                radio.send('rev')\n                print('rev')\n            elif key == 'pin1':\n                radio.send('left')\n                print('left')\n            elif key == 'pin2':\n                radio.send('right')\n                print('right')\n            elif key == 'pin12':\n                radio.send('spin_left')\n                print('spin_left')\n            elif key == 'pin16':\n                radio.send('spin_right')\n                print('spin_right')\n            else:\n                pass\n    radio.off()\n\n\n# instantiate the GamerBit class providing the callback function\ngb = GamerBit(gb_callback)\n\n\n\n\nAs shown on the \ngamerbit\n GitHub page, the library uses a callback\nmethod provided by the user, to process any button presses on the board. The function, gb_callback() handles\nall the button presses for this application. It translates the gamer:bit events to motor control strings\nand sends those strings over the micro:bit radio interface to the robot. The radio is turned on only to transmit the short\ncommand strings and then immediately turned off to preserve the battery life. \n\n\nRunning The Gamerbit Controller\n\n\n\n\nUsing your favorite mirco:bit editor, flash \ngb_remote_control.py\n on to a micro:bit.\n\n\nPlug the micro:bit in the gamer:bit.\n\n\nPower the micro:bit either with a USB cable or attaching a batter pack.",
            "title": "The Controllers"
        },
        {
            "location": "/controllers/#a-choice-of-4-remote-controllers",
            "text": "To demonstrate the flexibility of the micro:bit, 4 different remote controllers\nhave been developed:    A micro:bit  gesture  controller - translates micro:bit gestures into robot commands.    A Web Page GUI - provides 6 buttons in your browser to control the robot.    A tkinter GUI - provides 6 buttons on screen to control the robot.    A  SparkFun gamer:bit  push button interface.    The control protocol between the robot is consistent across all controllers, so the\n   robot only need be flashed once to use any of the controllers.",
            "title": "A Choice Of 4 Remote Controllers"
        },
        {
            "location": "/controllers/#1-gesture-controller",
            "text": "This controller consists of a standalone micro:bit. Robot motion is directed by \nchanging the micro:bit's orientation:     Point the USB connector towards the floor to direct the robot to go forward.    Point the USB connector towards the ceiling to direct the robot to go in reverse.    Point Button A (without pressing it )towards the floor to direct the robot to go left.    Point Button A (without pressing it )towards the ceiling to direct the robot to go right.    Press Button A to spin left.    Press Button B to spin right.    Hold the micro:bit parallel to the floor and ceiling, and the robot stops.    To use the gesture controller, flash  gesture_controller_min.py \n onto the controller micro:bit, and you are ready to go.",
            "title": "1. GESTURE CONTROLLER"
        },
        {
            "location": "/controllers/#gesture-controller-code",
            "text": "from microbit import *\nimport radio\n\n# the last gesture detected\nlast_gesture = ''\n\ndef send_command(cmd):\n    \"\"\"\n    This function sends a command to the radio.\n    :param cmd: Command string\n    :return:\n    \"\"\"\n    radio.on()\n    radio.send(cmd)\n    sleep(100)\n    radio.off()\n\n# the main loop\nwhile True:\n    # get the current gesture\n    gesture = accelerometer.current_gesture()\n\n    # if either button is pressed, translate this to\n    # a pseudo gesture\n    if button_a.is_pressed():\n        gesture = 'spin_left'\n    if button_b.is_pressed():\n        gesture = 'spin_right'\n\n    # if this gesture is different than the last,\n    # build the command string and transmit it over the radio.\n    if not last_gesture == gesture:\n        last_gesture = gesture\n        if gesture == 'down':\n            display.show(Image.ARROW_N)\n            send_command('fwd')\n        elif gesture == 'up':\n            display.show(Image.ARROW_S)\n            send_command('rev')\n        elif gesture == 'left':\n            display.show(Image.ARROW_W)\n            send_command('left')\n        elif gesture == 'right':\n            display.show(Image.ARROW_E)\n            send_command('right')\n        elif gesture == 'spin_left':\n            display.show(Image.ARROW_NW)\n            send_command('spin_left')\n        elif gesture == 'spin_right':\n            display.show(Image.ARROW_NE)\n            send_command('spin_right')\n        else:\n            display.show(Image.NO)\n            send_command('stop')  A motion control message is sent to the robot only if a new motion command is detected.\nThis helps preserve battery life for both the controller and the robot.  Looking at the event loop, it begins by retrieving the current micro:bit gesture.  It then checks the state of Button A and Button B to see if the user wishes to spin\nthe robot in either direction. If either of the buttons is currently pressed,\nthe button press is translated into a \"pseudo gesture\" and saved.\nThis allows the button presses to emulate the behavior of a true gesture change.  Next the current gesture is compared to the one saved from the previous cycle. If it is\nthe same, no action is taken, but if it is different, then the appropriate motion\nmessage is sent to the robot by passing the message to the send_command function. This function turns the\nradio on, transmits the command and then turns the radio off. \nIn addition an arrow image is displayed to show the motion\ncommand detected, or an \"X\" is displayed if the robot is stopped.",
            "title": "Gesture Controller Code"
        },
        {
            "location": "/controllers/#gui-based-controllers",
            "text": "The GUI based controllers each consist of 2 components. The first component is a Python script\nthat runs on a PC and connects to the controller micro:bit via the serial/USB cable. There are separate Python scripts \nfor each of the GUI controllers, that is\nthe Web based GUI and tkinter based GUI. These scripts\ndetect GUI button press events, and when an event change is detected, it sends a serial\nmessage to the micro:bit. The micro:bit translates these serial messages into radio commands\nand transmits those to the robot.",
            "title": "GUI BASED CONTROLLERS"
        },
        {
            "location": "/controllers/#the-gui_radio_bridge",
            "text": "As described above, the gui_radio_bridge translates serial messages generated\n by the GUI scripts into radio messages.  It needs to be flashed onto the controller micro:bit before either of the PC GUI scripts can run.  To flash the gui_radio_bridge, just copy the code from  gui_radio_bridge_min.py \nto your favorite micro:bit editor and flash it.",
            "title": "The gui_radio_bridge"
        },
        {
            "location": "/controllers/#the-gui_radio_bridge-code",
            "text": "from microbit import *\nimport radio\n\nwhile True:\n    # get data from serial link\n    data = uart.readline()\n    sleep(8)\n    if data:\n        # send data out over the radio\n        cmd = str(data, 'utf-8').rstrip()\n        radio.on()\n        radio.send(cmd)\n        radio.off()  The code for this script is very simple. The loop waits for an incoming line of text to be received\nover the serial link from the PC.\nWhen a line is received, it turns the radio on,\nsends the received string out via the radio interface, and then turns the radio off.",
            "title": "The gui_radio_bridge Code."
        },
        {
            "location": "/controllers/#2-the-web-page-gui-controller",
            "text": ".center {\n    margin: auto;\n    width: 85%;\n    padding: 10px;\n}</p>\n<p>",
            "title": "2. THE WEB PAGE GUI CONTROLLER"
        },
        {
            "location": "/controllers/#the-remi-gui-builder",
            "text": "The GUI Web page shown above, was created using a drag and drop editing tool included with the remi  GUI builder. Click on the  remi  link to the left if you are interested\nin learning how to use remi to create interactive web pages in pure Python.\nThe editor not only allows you to layout the web page, but it generates the code for the page as well,\nincluding stubs for any desired GUI events, such as button clicks. If you prefer to code directly in Python\nwithout the aid of the editor, the remi API is succinct and easy to understand.  The GUI and its associated web server are run on a PC, and it connects to a micro:bit via a serial USB link.\nThe code running on the controller micro:bit is the  gui_radio_bridge .\nThe bridge translates the serial commands coming from the GUI to micro:bit radio messages.  Before running this GUI, you will need to install remi on your PC, so please follow the \ninstallation instructions on the  remi GitHub home page .  I cannot emphasize enough how easily remi makes generating Web based GUIs. You don't have to know any HTML, CSS\nor JavaScript\nand can modify the page in pure Python. In addition, its author provides great support if you have questions\non using the tool.",
            "title": "The remi GUI Builder"
        },
        {
            "location": "/controllers/#web-gui-code",
            "text": "As mentioned earlier, the bulk of the code for this GUI was automatically generated by the remi editor.\nWhat will be shown and described here are the added or modified sections of code. Code that was not\nmodified, will not be shown or discussed. If you would like to\nsee the file in its entirety, please look at  web_remote_controller.py .  The entire Web GUI is encapsulated in a single Python class, called  RobotController .",
            "title": "Web GUI Code"
        },
        {
            "location": "/controllers/#modifications-or-additions-to-the-generated-code",
            "text": "",
            "title": "Modifications Or Additions To The Generated Code"
        },
        {
            "location": "/controllers/#__init__",
            "text": "In the  __init__  method, two lines were added to the generated code. The added code creates\nvariables to hold the serial com port, used to communicate with\nthe  gui_radio_bridge , and another variable to hold the instance of the serial object used to send data to the bridge.  class RobotController(App):\n    def __init__(self, *args, **kwargs):\n        self.com_port = None\n        self.micro_bit_serial = None\n        if not 'editing_mode' in kwargs.keys():\n            super(RobotController, self).__init__(*args, static_file_path='./res/')",
            "title": "__init__"
        },
        {
            "location": "/controllers/#main",
            "text": "The main method, generated by the editor consists of a single line, that calls the ui_constructor\nmethod that instantiates all the widgets on the page. This is the last line in the code below.  The code that has been added to  main  performs micro:bit serial port auto-detection.      def main(self):\n        print('Autodetecting serial port. Please wait...')\n        if sys.platform.startswith('darwin'):\n            locations = glob.glob('/dev/tty.[usb*]*')\n            locations = glob.glob('/dev/tty.[wchusb*]*') + locations\n            locations.append('end')\n            # for everyone else, here is a list of possible ports\n        else:\n            locations = ['dev/ttyACM0', '/dev/ttyACM0', '/dev/ttyACM1',\n                         '/dev/ttyACM2', '/dev/ttyACM3', '/dev/ttyACM4',\n                         '/dev/ttyACM5', '/dev/ttyUSB0', '/dev/ttyUSB1',\n                         '/dev/ttyUSB2', '/dev/ttyUSB3', '/dev/ttyUSB4',\n                         '/dev/ttyUSB5', '/dev/ttyUSB6', '/dev/ttyUSB7',\n                         '/dev/ttyUSB8', '/dev/ttyUSB9',\n                         '/dev/ttyUSB10',\n                         '/dev/ttyS0', '/dev/ttyS1', '/dev/ttyS2',\n                         '/dev/tty.usbserial', '/dev/tty.usbmodem', 'com2',\n                         'com3', 'com4', 'com5', 'com6', 'com7', 'com8',\n                         'com9', 'com10', 'com11', 'com12', 'com13',\n                         'com14', 'com15', 'com16', 'com17', 'com18',\n                         'com19', 'com20', 'com21', 'com22', 'com23', 'com24',\n                         'com25', 'com26', 'com27', 'com28', 'com29', 'com30',\n                         'com31', 'com32', 'com33', 'com34', 'com35', 'com36',\n                         'com1', 'end'\n                         ]\n\n        detected = None\n        for device in locations:\n            try:\n                self.micro_bit_serial = serial.Serial(port=device, baudrate=115200,\n                                                      timeout=.1)\n                detected = device\n                break\n            except serial.SerialException:\n                if device == 'end':\n                    print('Unable to find Serial Port, Please plug in '\n                          'cable or check cable connections.')\n                    detected = None\n                    exit()\n            except OSError:\n                pass\n        self.com_port = detected\n\n        # open and close the port to flush the serial buffers\n        self.micro_bit_serial.close()\n        self.micro_bit_serial.open()\n        time.sleep(.05)\n        print('Port found: ', self.com_port)\n        return RobotController.construct_ui(self)",
            "title": "main"
        },
        {
            "location": "/controllers/#construct_ui",
            "text": "This method is generated by the GUI editor and was not modified. It both instantiates all of the GUI widgets\nand peforms their layout on the web page.",
            "title": "construct_ui"
        },
        {
            "location": "/controllers/#the-event-handlers",
            "text": "The remi editor allows you to select events of interest for each widget, and then creates\na stub method to handle each event. You just need to add the code specific to your application for\nthat event.  Let's look at the handlers for the  Forward  button. Handlers for all of the other buttons are very similar.      def onmousedown_btn_forward(self, emitter, x, y):\n        print('fdown')\n        self.write_to_mb('fwd')\n\n    def onmouseup_btn_forward(self, emitter, x, y):\n        print('fup')\n        self.write_to_mb('stop')  There are 2 events associated with this button, that is, when the button is pressed and when it is released.\nThe print statements were added to send debugging information to the console, and can optionally be\ndeleted.",
            "title": "The Event Handlers"
        },
        {
            "location": "/controllers/#write_to_mb",
            "text": "The  write_to_mb  method sends the command over the serial port to the micro:bit. It is an additional method added to the \nRobotController class.      def write_to_mb(self, msg):\n        msg = bytes(msg.encode())\n        self.micro_bit_serial.write(msg)",
            "title": "write_to_mb"
        },
        {
            "location": "/controllers/#gui-instantiation",
            "text": "The last section of the code instantiates the GUI.  configuration = {'config_project_name': 'RobotController', \n                 'config_address': '0.0.0.0', 'config_port': 8081, \n                 'config_multiple_instance': True, \n                 'config_enable_file_cache': True, \n                 'config_start_browser': True, 'config_resourcepath': './res/'}\n\nif __name__ == \"__main__\":\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    # use the google dns\n    s.connect(('8.8.8.8', 0))\n    # start(MyApp,address='127.0.0.1', port=8081, \n    #       multiple_instance=False,enable_file_cache=True, \n    #       update_interval=0.1, start_browser=True)\n    start(RobotController, address=s.getsockname()[0], port=configuration['config_port'],\n                        multiple_instance=configuration['config_multiple_instance'],\n                        enable_file_cache=configuration['config_enable_file_cache'],\n                        start_browser=configuration['config_start_browser'])  Most of this code was generated by the editor. The  configuration  dictionary was not modified. It contains\ndefault entries that can be used when instantiating the GUI.  The default IP address for the web server is 127.0.0.0.1 as shown in the commented out  start  line. I wanted to be\nable to expose the web server to browsers on other computers, so the s.connect and s.getsockname calls allow\nfor discovery of the IP address of the machine running the webserver. The rest of the parameters are \nthe system defaults, and you can find out more about those on the  remi  GitHub page.",
            "title": "GUI Instantiation"
        },
        {
            "location": "/controllers/#running-the-web-based-gui",
            "text": "Flash the  gui_radio_bridge  on to the micro:bit acting as the remote.  Connect the micro:bit to the computer that will run the GUI with a USB cable.  Run  web_remote_controller.py  from a command or terminal window.   Open up your web browser and use the announced httpserver URL to \n   access the GUI. For example  http://192.168.2.188:8081        $ python3 web_remote_controller.py\n        remi.server      INFO     Started websocket server 192.168.2.188:43723\n        remi.server      INFO     Started httpserver http://192.168.2.188:8081/\n        remi.request     INFO     built UI (path=/)\n        Autodetecting serial port. Please wait...\n        Port found:  /dev/ttyACM0\n        remi.server.ws   INFO     connection established: ('192.168.2.188', 54508)\n        remi.server.ws   INFO     handshake complete  Pressing a GUI button initiates motor movement, and releasing it stops the motors.",
            "title": "Running The Web Based GUI"
        },
        {
            "location": "/controllers/#3-the-tkinter-gui-controller",
            "text": "The tkinter GUI runs on a PC, and it connects to a micro:bit via a serial USB link.\nThe code running on the micro:bit is the  gui_radio_bridge .\nThe bridge translates the serial commands coming from the GUI to micro:bit radio messages.",
            "title": "3. THE TKINTER GUI CONTROLLER"
        },
        {
            "location": "/controllers/#tk_controller-code",
            "text": "The code is structured similarly to the remi gui. Since tkinter programming is beyond the\nscope of this guide, this discussion will be limited to one of general functionality. If you wish to\nlearn more about creating tkinter applications, I can recommend \"Modern Tkinter for Busy Python Developers\", by Mark Roseman \n as a reference.  You may refer to the actual source code by looking at  tk_controller.py .  The  __init__  method:   Auto-detects the micro:bit serial port  Initializes the tkinter framework   Calls the  create_control_frame  method.   Create_control_frame instantiates and performs layout for all the GUI widgets  Associates event handlers for each widget.      Event handlers are provided for each GUI event identified in  create_control_frame .",
            "title": "tk_controller Code"
        },
        {
            "location": "/controllers/#running-the-tkinter-based-gui",
            "text": "Flash the  gui_radio_bridge  on to the micro:bit acting as the remote.  Connect the micro:bit to the computer that will run the GUI using a USB cable.  Run  tk_controller.py  from a command or terminal window.         python3 tk_controller.py  Pressing a button initiates robot motion and when a button is released robot motion is stopped.",
            "title": "Running The tkinter Based GUI"
        },
        {
            "location": "/controllers/#4-the-gamerbit-controller",
            "text": "This controller requires the purchase of a  SparkFun gamer:bit  The buttons on the left hand side of the gamer:bit are used to control forward, reverse, left and right motion.\nThe buttons on the right control both left and right spinning motion.  Pressing a button initiates robot motion and when a button is released robot motion is stopped.",
            "title": "4. THE GAMER:BIT CONTROLLER"
        },
        {
            "location": "/controllers/#gamerbit-code",
            "text": "The code for this controller utilizes the  gamerbit  third party library .  If you look at  gb_remote_control.py , the gamerbit library, that is, the GamerBit class, \nis placed at the top of the file.  class GamerBit:\n    def __init__(self, callback, scans=1):\n        self.pins = [pin0, pin1, pin2, pin8, pin12, pin16, button_a, button_b]\n        self.callback = callback\n        self.number_of_scans = scans\n        for pin in self.pins[:-2]:\n            pin.set_pull(pin.PULL_UP)\n        self.previous_readings = [0] * 8\n        self.current_readings = [0] * 8\n        self._scanner()\n\n    def scan(self):\n        readings = [int(not pin.read_digital()) for pin in self.pins[:-2]]\n        readings.append(int(button_a.is_pressed()))\n        readings.append(int(button_b.is_pressed()))\n        self.current_readings = [int(self.current_readings[pin] or readings[pin]) for pin in range(0, len(readings))]\n\n    def _scanner(self):\n        pin_ids = ['pin0', 'pin1', 'pin2', 'pin8', 'pin12', 'pin16', 'button_a', 'button_b']\n        while True:\n            for scans in range(0, self.number_of_scans):\n                self.scan()\n            report = {}\n            for x in range(0, 8):\n                if self.current_readings[x] != self.previous_readings[x]:\n                    report[pin_ids[x]] = self.current_readings[x]\n            self.previous_readings = self.current_readings\n            self.current_readings = [0] * 8\n            if report:\n                if self.callback:\n                    self.callback(report)\n\n\ndef gb_callback(report):\n    \"\"\"\n    This function is called by the GamerBit class when a button\n    state change is detected. It translates the button presses\n    and releases into messages that are sent over the radio\n    interface and received by microbit_robot.py\n    :param report: A GamerBit report dictionary\n    :return:\n    \"\"\"\n    # turn on the radio\n    radio.on()\n    for key in report:\n        value = report[key]\n        # if the button was released, send a stop command\n        if value == 0:\n            radio.send('stop')\n            radio.send('stop')\n            sleep(10)\n            radio.send('stop')\n\n        # send a command associated with each button\n        else:\n            if key == 'pin0':\n                radio.send('fwd')\n                print('fwd')\n            elif key == 'pin8':\n                radio.send('rev')\n                print('rev')\n            elif key == 'pin1':\n                radio.send('left')\n                print('left')\n            elif key == 'pin2':\n                radio.send('right')\n                print('right')\n            elif key == 'pin12':\n                radio.send('spin_left')\n                print('spin_left')\n            elif key == 'pin16':\n                radio.send('spin_right')\n                print('spin_right')\n            else:\n                pass\n    radio.off()\n\n\n# instantiate the GamerBit class providing the callback function\ngb = GamerBit(gb_callback)  As shown on the  gamerbit  GitHub page, the library uses a callback\nmethod provided by the user, to process any button presses on the board. The function, gb_callback() handles\nall the button presses for this application. It translates the gamer:bit events to motor control strings\nand sends those strings over the micro:bit radio interface to the robot. The radio is turned on only to transmit the short\ncommand strings and then immediately turned off to preserve the battery life.",
            "title": "Gamerbit Code"
        },
        {
            "location": "/controllers/#running-the-gamerbit-controller",
            "text": "Using your favorite mirco:bit editor, flash  gb_remote_control.py  on to a micro:bit.  Plug the micro:bit in the gamer:bit.  Power the micro:bit either with a USB cable or attaching a batter pack.",
            "title": "Running The Gamerbit Controller"
        },
        {
            "location": "/contact/",
            "text": "If you have any comments or questions about this guide, the microbit_robot project or \nthe kitronik motor controller or gamer:bit libraries, please send an email to:\n\nMisterYsLab@gmail.com\n\n\nOr enter an issue at\n\nhttps://github.com/MrYsLab/microbit-robot",
            "title": "Contact Information"
        }
    ]
}